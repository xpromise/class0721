# Vue 原理

## 响应式原理

1. 数据代理：将 `data` 中的数据代理 `this` 上，访问数据更方便

- 详细版

  - 将 `data` 数据赋值给变量 `data` 和 `this._data` 上，这种数据称为原数据
  - 通过 `Object.keys` 方法提取原数据的所有属性名成为一个数组
  - 遍历这个数据，调用 `_proxy` 对每一个属性名进行数据代理
  - 所谓数据：就是通过 `Object.defineProperty` 方法给 `this` 定义这个属性，设置属性的元属性（属性描述符）
  - 元属性中定义数据的是否可枚举，是否可以重新配置，以及 `get` 属性读取方法 和 `set` 属性的设置方法
  - `get` 和 `set` 方法本质上都是对之前的原数据进行操作
  - 到此所有数据都会定义在 `this` 上，所以可以通过 `this` 直接访问 `data` 中数据了

- 简单版
  - 遍历所有原数据中属性进行数据代理，通过 `Object.defineProperty` 方法给 `this` 添加属性，定义其 `get` 和 `set` 方法，内部实际读取、设置还是原数据的值

2. 数据劫持：重新定义 `data` 原数据上的属性，将其定义响应式属性

- 详细版

  - 调用 `observe` 方法开始数据劫持，传入 `data` 原数据
  - 判断数据是否是对象或数组，是的话才会开始真正的工作 `new Obverser(data)`
  - 内部通过 `Object.keys` 方法提取原 `data` 数据的所有属性名成为一个数组
  - 遍历这个数组，提取属性名和属性值，调用 `defineReactive` 方法将其定义成响应式
  - 先 `new Dep()` 生成 `dep` 对象，这个 `dep` 可以做两件事
    - 可以通过建立响应式联系（`dep.depend`）
    - 可以触发响应式更新（`dep.notify`）
    - 每个响应式数据都会产生一个自己的 `dep`，它是唯一的
  - 递归调用 `observe` 函数，对属性值进行处理
    - 它的目的为了确保所有数据（对象上对象上的数据）都变成响应式
  - 通过 `Object.defineProperty` 方法给原数据 `data` 重新定义属性，定义其属性 `get` 和 `set` 方法，
    - `get` 方法会返回原数据（内部会有 `dep.depend` 方法）
    - `set` 方法设置新值，通过调用 `observe` 方法将新值重新定义成响应式（内部会有 `dep.notify` 方法）
      - 确保将来所有 `data` 数据都是响应式（不管是之前的，还是新添加的）
  - 此时 `data` 数据就全部重新定义了，定义成响应式，响应式的关键点还是看下一步

- 简单版
  - 内部会递归遍历所有 `data` 数据，将其定义成响应式
  - 每个响应式数据都会产生一个自己的 `dep`，它是唯一的，和响应式关系很大
  - 通过 `Object.defineProperty` 方法给原数据 `data` 重新定义属性，定义其属性 `get` 和 `set` 方法

3. 模板解析: 解析模板中插值语法和指令语法

- 详细版

  - 从`new Compile()`开，一共三个步骤
  - 将 el 的所有子节点添加到文档碎片节点中
    - 遍历 el 的子节点添加文档碎片中
    - 一旦节点添加文档碎片中，节点就会自动从 DOM 消失
  - 解析、编译文档碎片的模板代码
    - 取出子节点进行遍历
    - 判断节点是否是元素节点
      - 如果是元素节点，进行解析元素的指令语法
      - 取出元素的所有属性节点，进行遍历
      - 判断是否是指令属性（v-）
        - 如果是，还要判断是否是事件指令（on）
          - 如果是，就是事件指令，给元素绑定事件和相应的回调函数，回调函数通过 bind 方法改变 this 指向为 vm
          - 如果不是，就是一般指令
            - compileUtil['xxx'] --> bind --> xxxUpdaterFn --> 操作 DOM 元素
              - 比如：v-text 操作元素 textContent 属性，值为表达式的值
            - 注意最后会 new watcher()，会将更新数据的 updater 函数传入，这个 new Watcher 建立响应式联系的入口
          - 解析完指令后，会将指令属性给移除掉
        - 如果不是，就不处理这个属性
    - 再判断节点是否是文本节点且包含插值语法
      - 满足条件，进行解析文本的插值语法
        - 和 v-text 指令解析类似，都是最终调用 textUpdater 方法去更新元素的 textContent 的值
        - 注意最后会 new watcher()
    - 最后判断当前节点是否有子节点，如果有就要递归调用，对所有子节点编译
      - 目的：为了解析模板中所有节点
  - 将解析后的文档碎片代码添加到 el 中生效

- 简单版

  - 将 el 的所有子节点添加到文档碎片节点中
  - 解析、编译文档碎片的模板代码
    - 解析分为指令语法和插值语法
    - 元素节点解析指令语法，文本节点解析插值语法
    - 解析指令语法，会根据具体的指令进行相应的解析
      - v-on 给元素绑定事件
      - v-text 会设置元素 textContent
    - 解析插值语法，就会给元素设置 textContent
    - 最终：解析处理事件指令以外的其他指令和插值语法，会 new Watcher(), 这个就会建立起响应式联系
  - 将解析后的文档碎片代码添加到 el 中生效

- new Watcher()是如何建立起响应式联系的

  - new Watcher() 此时会去原数据上读取表达式值
  - 会触发数据劫持阶段给原数据属性绑定的 get 方法
  - get 方法中会调用 dep.depend()，此时就会建立响应式联系
  - 响应式联系：会在 dep 中保存相应的 watcher，wacher 中保存相应的 dep
    - dep 中保存相应的 watcher 的目的：为了将来更新数据时，调用 dep 中的所有 watcher.update 方法去更新用户界面
    - wacher 中保存相应的 dep 的目的：为了防止 dep 重复保存相同的 watcher

- 到此建立响应式联系

- 响应式触发：
  - 当更新数据时
  - 首先触发 数据代理阶段给 this 设置的属性的 set 方法，内部实际操作的是 data 原数据
  - 操作原数据，又会触发 数据劫持阶段给原数据属性绑定的 set 方法,
  - set 方法中会更新数据，同时调用 dep.notify 方法
  - dep.notify 方法内部会遍历所有保存的 watcher 去调用更新用户界面的方法
  - 从而实现，数据发生变化，页面也发生变化，达到响应式

## 双向数据绑定原理

- v-model 指令如何做到双向数据绑定

- v-model 指令
  - 给元素绑定 value 属性，值为表达式的值，此时数据 Model --> View
  - 继续给元素绑定 input 事件，在事件回调函数中通过 e.target.value 收集用户输入的数据
  - 更新原 data 数据为 e.target.value，此时数据 View --> Model
  - 从而实现双向数据绑定
  - 原理：给元素绑定 value 属性和 input 事件来完成的
